#!/bin/bash
# cca - Claude Code AutoFlow CLI
# Manage AutoFlow skill installations across projects

set -euo pipefail
shopt -s nullglob

VERSION="1.0.0"
GIT_COMMIT=""
GIT_DATE=""

CCA_HOME="${CCA_HOME:-${XDG_CONFIG_HOME:-$HOME/.config}/cca}"
CCA_CACHE="${CCA_CACHE:-${XDG_CACHE_HOME:-$HOME/.cache}/cca}"
CCA_INSTALL_PREFIX="${CCA_INSTALL_PREFIX:-$HOME/.local/share/cca}"
CCA_BIN_DIR="${CCA_BIN_DIR:-$HOME/.local/bin}"

CCA_REPO_GIT="https://github.com/bfly123/claude_code_autoflow.git"
CCA_REPO_URL="${CCA_REPO_GIT%.git}"
CCA_REPO_API="https://api.github.com/repos/bfly123/claude_code_autoflow/commits/main"
INSTALLATIONS_FILE="$CCA_HOME/installations"

resolve_script_path() {
    local src="$1"
    while [[ -L "$src" ]]; do
        local dir
        dir="$(cd -P "$(dirname "$src")" && pwd)"
        src="$(readlink "$src")"
        [[ "$src" != /* ]] && src="$dir/$src"
    done
    local dir
    dir="$(cd -P "$(dirname "$src")" && pwd)"
    echo "$dir/$(basename "$src")"
}

CCA_SCRIPT_PATH="$(resolve_script_path "${BASH_SOURCE[0]}")"
CCA_SCRIPT_ROOT="$(cd "$(dirname "$CCA_SCRIPT_PATH")" && pwd)"

# Default source path:
# - env CCA_SOURCE (if set)
# - resolved script directory (symlink-aware)
CCA_SOURCE="${CCA_SOURCE:-$CCA_SCRIPT_ROOT}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Ensure CCA_HOME and cache exist
mkdir -p "$CCA_HOME" "$CCA_CACHE"
touch "$INSTALLATIONS_FILE"

usage() {
    cat << EOF
cca - Claude Code AutoFlow CLI v$VERSION

Usage: cca <command> [options]

Commands:
  add .          Configure Codex permissions for current project
  add <path>     Configure Codex permissions for a project

  delete .       Remove Codex permissions config for current project
  delete <path>  Remove Codex permissions config for a project

  update [--local]  Update cca and refresh ~/.claude/
  list           Show configured projects
  uninstall      Remove cca from system

  version        Show version and commit info
  help           Show this help

Examples:
  cca add .                  # Configure current project
  cca add ~/myproject        # Configure a project
  cca delete .               # Remove config from current project
  cca update                 # Update cca and refresh ~/.claude/
  cca update --local         # Refresh ~/.claude/ from current CCA_SOURCE

Config:
  CCA_HOME=$CCA_HOME
  CCA_INSTALL_PREFIX=$CCA_INSTALL_PREFIX
  CCA_SOURCE=$CCA_SOURCE
EOF
}

log_info() { printf "${GREEN}[+]${NC} %s\n" "$1"; }
log_warn() { printf "${YELLOW}[!]${NC} %s\n" "$1"; }
log_error() { printf "${RED}[-]${NC} %s\n" "$1"; }
log_blue() { printf "${BLUE}[*]${NC} %s\n" "$1"; }

AUTOFLOW_SKILLS=(tr tp dual-design file-op ask-codex ask-gemini roles review mode-switch docs)
AUTOFLOW_COMMANDS=(tr.md tp.md dual-design.md file-op.md ask-codex.md ask-gemini.md roles.md review.md mode-switch.md auto.md)

detect_platform() {
    local name
    name="$(uname -s 2>/dev/null || echo unknown)"
    case "$name" in
        Linux) echo "linux" ;;
        Darwin) echo "macos" ;;
        *) echo "unknown" ;;
    esac
}

require_platform() {
    local p
    p="$(detect_platform)"
    if [[ "$p" != "linux" && "$p" != "macos" ]]; then
        log_error "Unsupported platform: $(uname -s 2>/dev/null || echo unknown) (Linux/macOS only)"
        exit 1
    fi
}

sed_inplace() {
    # Portable in-place edit for GNU sed and BSD/macOS sed.
    # Usage: sed_inplace 's/old/new/' file
    local script="$1"
    local file="$2"
    sed -i.bak "$script" "$file"
    rm -f "${file}.bak"
}

toml_escape_basic() {
    # Escape backslashes and double quotes for TOML basic strings.
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//\"/\\\"}"
    printf "%s" "$s"
}

update_codex_config() {
    local target_path="$1"
    local codex_cfg="$HOME/.codex/config.toml"

    if [[ ! -f "$codex_cfg" ]]; then
        log_warn "Codex config not found: $codex_cfg (skipping auto-approval setup)"
        return 0
    fi
    if [[ ! -w "$codex_cfg" ]]; then
        log_warn "Codex config not writable: $codex_cfg (skipping auto-approval setup)"
        return 0
    fi

    local escaped_path
    escaped_path="$(toml_escape_basic "$target_path")"
    local header="[projects.\"$escaped_path\"]"

    local tmp
    tmp="$(mktemp "${CCA_HOME}/codex-config.tmp.XXXXXX")"

    if grep -Fq -- "$header" "$codex_cfg"; then
        # Ensure approval_policy = "never" exists within this project section.
        awk -v header="$header" '
            function print_approval() { print "approval_policy = \"never\"" }
            BEGIN { in_section = 0; found = 0 }
            {
                line = $0
                if (line ~ /^\[[^]]+\]$/) {
                    if (in_section == 1) {
                        if (found == 0) print_approval()
                        in_section = 0
                    }
                    if (line == header) {
                        in_section = 1
                        found = 0
                        print line
                        next
                    }
                }
                if (in_section == 1 && line ~ /^[[:space:]]*approval_policy[[:space:]]*=/) {
                    print_approval()
                    found = 1
                    next
                }
                print line
            }
            END {
                if (in_section == 1 && found == 0) print_approval()
            }
        ' "$codex_cfg" > "$tmp" || { rm -f "$tmp"; log_warn "Failed to update Codex config (parse error): $codex_cfg"; return 0; }
        if ( cat "$tmp" > "$codex_cfg" ) 2>/dev/null; then
            rm -f "$tmp"
            log_info "Codex auto-approval ensured (approval_policy=never): $target_path"
        else
            rm -f "$tmp"
            log_warn "Failed to update Codex config (write denied): $codex_cfg"
        fi
        return 0
    fi

    # Append new project config block.
    cat "$codex_cfg" > "$tmp" || { rm -f "$tmp"; log_warn "Failed to read Codex config: $codex_cfg"; return 0; }
    {
        echo ""
        echo "$header"
        echo "trust_level = \"trusted\""
        echo "approval_policy = \"never\""
        echo "sandbox_mode = \"full-auto\""
    } >> "$tmp"
    if ( cat "$tmp" > "$codex_cfg" ) 2>/dev/null; then
        rm -f "$tmp"
        log_info "Codex auto-approval configured for project: $target_path"
    else
        rm -f "$tmp"
        log_warn "Failed to update Codex config (write denied): $codex_cfg"
    fi
}

remove_codex_config() {
    local target_path="$1"
    local codex_cfg="$HOME/.codex/config.toml"

    if [[ ! -f "$codex_cfg" ]]; then
        log_warn "Codex config not found: $codex_cfg (skipping removal)"
        return 0
    fi
    if [[ ! -w "$codex_cfg" ]]; then
        log_warn "Codex config not writable: $codex_cfg (skipping removal)"
        return 0
    fi

    local escaped_path
    escaped_path="$(toml_escape_basic "$target_path")"
    local header="[projects.\"$escaped_path\"]"

    if ! grep -Fq -- "$header" "$codex_cfg" 2>/dev/null; then
        log_warn "Codex project config not found (already removed): $target_path"
        return 0
    fi

    local tmp
    tmp="$(mktemp "${CCA_HOME}/codex-config.tmp.XXXXXX")"

    awk -v header="$header" '
        BEGIN { skip = 0 }
        {
            line = $0
            if (line ~ /^\[[^]]+\]$/) {
                if (skip == 1) skip = 0
                if (line == header) { skip = 1; next }
            }
            if (skip == 1) next
            print line
        }
    ' "$codex_cfg" > "$tmp" || { rm -f "$tmp"; log_warn "Failed to update Codex config (parse error): $codex_cfg"; return 0; }

    if ( cat "$tmp" > "$codex_cfg" ) 2>/dev/null; then
        rm -f "$tmp"
        log_info "Codex project config removed: $target_path"
    else
        rm -f "$tmp"
        log_warn "Failed to update Codex config (write denied): $codex_cfg"
    fi
}

codex_project_configured() {
    local target_path="$1"
    local codex_cfg="$HOME/.codex/config.toml"
    [[ -f "$codex_cfg" ]] || return 1

    local escaped_path
    escaped_path="$(toml_escape_basic "$target_path")"
    local header="[projects.\"$escaped_path\"]"
    grep -Fq -- "$header" "$codex_cfg" 2>/dev/null
}

canonical_path() {
    # Prefer realpath; fall back to Python for portability.
    local p="$1"
    if command -v realpath >/dev/null 2>&1; then
        realpath "$p"
        return 0
    fi
    python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$p"
}

system_install_dir() {
    if [[ -d "$CCA_INSTALL_PREFIX" && -f "$CCA_INSTALL_PREFIX/cca" && -f "$CCA_INSTALL_PREFIX/install.sh" ]]; then
        echo "$CCA_INSTALL_PREFIX"
        return 0
    fi
    return 1
}

get_local_version_info() {
    local dir="$1"
    local commit="$GIT_COMMIT"
    local date="$GIT_DATE"

    if [[ -z "${commit:-}" ]] && command -v git >/dev/null 2>&1 && [[ -d "$dir/.git" ]]; then
        commit="$(git -C "$dir" log -1 --format='%h' 2>/dev/null || true)"
        date="$(git -C "$dir" log -1 --format='%cs' 2>/dev/null || true)"
    fi

    printf "%s|%s\n" "${commit:-}" "${date:-}"
}

get_installed_version_info() {
    # Best-effort version read for an installed directory.
    # Prefer git metadata when available; fall back to reading injected variables from cca file.
    local dir="$1"
    local commit=""
    local date=""

    if command -v git >/dev/null 2>&1 && [[ -d "$dir/.git" ]]; then
        commit="$(git -C "$dir" rev-parse --short HEAD 2>/dev/null || true)"
        date="$(git -C "$dir" log -1 --format='%cs' 2>/dev/null || true)"
        printf "%s|%s\n" "${commit:-}" "${date:-}"
        return 0
    fi

    if [[ -f "$dir/cca" ]]; then
        # Accept either single or double quotes; ignore trailing whitespace.
        commit="$(grep -E '^GIT_COMMIT=' "$dir/cca" 2>/dev/null | head -1 | sed -E 's/^GIT_COMMIT=//; s/[[:space:]]+$//; s/^"//; s/"$//; s/^'\''//; s/'\''$//' 2>/dev/null || true)"
        date="$(grep -E '^GIT_DATE=' "$dir/cca" 2>/dev/null | head -1 | sed -E 's/^GIT_DATE=//; s/[[:space:]]+$//; s/^"//; s/"$//; s/^'\''//; s/'\''$//' 2>/dev/null || true)"
    fi

    printf "%s|%s\n" "${commit:-}" "${date:-}"
}

get_installed_version_string() {
    local dir="$1"
    local commit date
    IFS='|' read -r commit date <<< "$(get_installed_version_info "$dir")"

    if [[ -z "${commit:-}" && -z "${date:-}" ]]; then
        printf "%s\n" "(unknown)"
        return 0
    fi

    if [[ -n "${commit:-}" && -n "${date:-}" ]]; then
        printf "%s %s\n" "$commit" "$date"
        return 0
    fi

    printf "%s\n" "${commit:-${date:-}}"
}

get_remote_version_info() {
    command -v curl >/dev/null 2>&1 || command -v wget >/dev/null 2>&1 || return 1
    local api_response commit date
    if command -v curl >/dev/null 2>&1; then
        api_response="$(curl -fsSL "$CCA_REPO_API" 2>/dev/null || true)"
    else
        api_response="$(wget -q -O - "$CCA_REPO_API" 2>/dev/null || true)"
    fi
    [[ -n "$api_response" ]] || return 1

    commit="$(echo "$api_response" | grep -o '"sha": "[^"]*"' | head -1 | cut -d'"' -f4 | cut -c1-7)"
    date="$(echo "$api_response" | grep -o '"date": "[^"]*"' | head -1 | cut -d'"' -f4 | cut -c1-10)"
    [[ -n "${commit:-}" ]] || return 1
    printf "%s|%s\n" "${commit:-}" "${date:-}"
}

# Record installation path
record_installation() {
    local path="$1"
    local type="$2"  # project or system
    local install_date="${3:-$(date +%Y-%m-%d)}"
    # Remove existing entry if any
    local tmp
    tmp="$(mktemp "${INSTALLATIONS_FILE}.tmp.XXXXXX")"
    grep -Fv -- "$path|" "$INSTALLATIONS_FILE" > "$tmp" 2>/dev/null || true
    mv "$tmp" "$INSTALLATIONS_FILE"
    # Add new entry with trailing newline
    printf "%s|%s|%s\n" "$path" "$type" "$install_date" >> "$INSTALLATIONS_FILE"
}

# Remove installation record
remove_installation() {
    local path="$1"
    local tmp
    tmp="$(mktemp "${INSTALLATIONS_FILE}.tmp.XXXXXX")"
    grep -Fv -- "$path|" "$INSTALLATIONS_FILE" > "$tmp" 2>/dev/null || true
    mv "$tmp" "$INSTALLATIONS_FILE"
}

# Check source files exist (for refreshing ~/.claude/)
check_source_dir() {
    local source_root="${1:-$CCA_SOURCE}"
    if [[ ! -d "$source_root/claude_source/skills" ]]; then
        log_error "Skills not found in $source_root/claude_source/skills/"
        log_error "Set CCA_SOURCE to your AutoFlow repository directory"
        exit 1
    fi
    if [[ ! -d "$source_root/claude_source/commands" ]]; then
        log_error "Commands not found in $source_root/claude_source/commands/"
        exit 1
    fi

    for skill in "${AUTOFLOW_SKILLS[@]}"; do
        if [[ ! -d "$source_root/claude_source/skills/$skill" ]]; then
            log_error "Missing AutoFlow skill in source: $source_root/claude_source/skills/$skill"
            exit 1
        fi
    done
}

install_global_skills() {
    local source_root="$1"
    check_source_dir "$source_root"

    local target="$HOME/.claude"
    mkdir -p "$target/skills" "$target/commands"

    for skill in "${AUTOFLOW_SKILLS[@]}"; do
        rm -rf "$target/skills/$skill" 2>/dev/null || true
        cp -a "$source_root/claude_source/skills/$skill" "$target/skills/"
    done

    # Commands: strict mirror for cca-managed commands without touching user custom commands.
    local owned="$target/commands/.cca-owned"
    if [[ -f "$owned" ]]; then
        while IFS= read -r name; do
            [[ -z "${name//[[:space:]]/}" ]] && continue
            rm -f "$target/commands/$name" 2>/dev/null || true
        done < "$owned"
    else
        # Bootstrap cleanup: remove previously installed AutoFlow command wrappers (best effort).
        # Matches files that reference known ~/.claude/skills/<skill>/ paths.
        for f in "$target/commands"/*.md; do
            [[ -f "$f" ]] || continue
            if grep -qF '~/.claude/skills/' "$f" 2>/dev/null; then
                if grep -Eq '~/.claude/skills/(tr|tp|dual-design|file-op|ask-codex|ask-gemini|roles|review|mode-switch|docs)/' "$f" 2>/dev/null; then
                    rm -f "$f" 2>/dev/null || true
                fi
            fi
        done
    fi

    : > "$owned" 2>/dev/null || true
    for cmd in "${AUTOFLOW_COMMANDS[@]}"; do
        if [[ -f "$source_root/claude_source/commands/$cmd" ]]; then
            cp -a "$source_root/claude_source/commands/$cmd" "$target/commands/"
            printf "%s\n" "$cmd" >> "$owned" 2>/dev/null || true
        else
            log_warn "Missing command in source (skipping): $source_root/claude_source/commands/$cmd"
        fi
    done

    log_info "Installed skills/commands to ~/.claude/ (globally visible)"
}

ensure_system_roles_config() {
    local roles_cfg="$CCA_HOME/roles.json"
    if [[ -f "$roles_cfg" ]]; then
        return 0
    fi
    cat > "$roles_cfg" <<'JSON'
{
  "schemaVersion": 1,
  "enabled": true,
  "executor": "codex",
  "reviewer": "codex",
  "documenter": "codex",
  "designer": ["claude", "codex"]
}
JSON
    log_info "Created system roles config: $roles_cfg"
}

ensure_project_roles_config() {
    local project_root="$1"
    local target_dir="$project_root/.autoflow"
    local target_file="$target_dir/roles.json"
    local template="$CCA_SOURCE/claude_source/templates/roles.json"

    if [[ -f "$target_file" ]]; then
        log_warn "Project roles config already exists: $target_file"
        return 0
    fi

    mkdir -p "$target_dir" 2>/dev/null || true
    if [[ -f "$template" ]]; then
        if cp -n "$template" "$target_file" 2>/dev/null; then
            :
        else
            cp "$template" "$target_file"
        fi
        log_info "Installed project roles config: $target_file"
    else
        log_warn "Roles template not found (skipping): $template"
    fi
}

ensure_hook_installed() {
    local bin_dir="$CCA_BIN_DIR"
    bin_dir="$(dirname "$(command -v cca 2>/dev/null || echo "$CCA_BIN_DIR/cca")")"
    local src="$CCA_SOURCE/cca-roles-hook"
    local dst="$bin_dir/cca-roles-hook"

    if [[ ! -f "$src" ]]; then
        log_warn "Hook script not found (skipping install): $src"
        return 0
    fi

    mkdir -p "$bin_dir" 2>/dev/null || true
    if cp -f "$src" "$dst" 2>/dev/null; then
        chmod +x "$dst" 2>/dev/null || true
        log_info "Installed hook: $dst"
    else
        log_warn "Failed to install hook to: $dst (permission denied?)"
    fi
}

sync_bin_tools() {
    # Ensure cca and helper scripts are present in bin dir (needed after git-based update).
    local install_dir="$1"
    local bin_dir="$CCA_BIN_DIR"
    bin_dir="$(dirname "$(command -v cca 2>/dev/null || echo "$CCA_BIN_DIR/cca")")"

    mkdir -p "$bin_dir" 2>/dev/null || true

    if [[ -f "$install_dir/cca" ]]; then
        chmod +x "$install_dir/cca" 2>/dev/null || true
        if ln -sf "$install_dir/cca" "$bin_dir/cca" 2>/dev/null; then
            :
        else
            cp -f "$install_dir/cca" "$bin_dir/cca" 2>/dev/null || true
            chmod +x "$bin_dir/cca" 2>/dev/null || true
        fi
        log_info "Synced: $bin_dir/cca"
    else
        log_warn "Missing installed cca (skipping bin sync): $install_dir/cca"
    fi

    if [[ -f "$install_dir/cca-roles-hook" ]]; then
        chmod +x "$install_dir/cca-roles-hook" 2>/dev/null || true
        if ln -sf "$install_dir/cca-roles-hook" "$bin_dir/cca-roles-hook" 2>/dev/null; then
            :
        else
            cp -f "$install_dir/cca-roles-hook" "$bin_dir/cca-roles-hook" 2>/dev/null || true
            chmod +x "$bin_dir/cca-roles-hook" 2>/dev/null || true
        fi
        log_info "Synced: $bin_dir/cca-roles-hook"
    else
        log_warn "Missing hook script in install dir (skipping bin sync): $install_dir/cca-roles-hook"
    fi
}

ensure_claude_settings_hook() {
    local project_root="$1"
    local claude_dir="$project_root/.claude"
    local settings="$claude_dir/settings.json"

    mkdir -p "$claude_dir" 2>/dev/null || true

    # Merge/update JSON safely via python. If invalid JSON, skip to avoid clobbering.
    python3 - "$settings" <<'PY'
import json, os, sys
from pathlib import Path

settings_path = Path(sys.argv[1])
hook_obj = {"matcher": ".*", "commands": ["cca-roles-hook"]}

data = {}
if settings_path.exists():
    try:
        data = json.loads(settings_path.read_text(encoding="utf-8"))
        if not isinstance(data, dict):
            raise ValueError("settings.json is not an object")
    except Exception:
        # Do not overwrite unknown/invalid config.
        sys.exit(2)

hooks = data.get("hooks")
if not isinstance(hooks, dict):
    hooks = {}
    data["hooks"] = hooks

pre = hooks.get("PreToolUse")
if not isinstance(pre, list):
    pre = []
    hooks["PreToolUse"] = pre

def has_hook(entry):
    if not isinstance(entry, dict):
        return False
    cmds = entry.get("commands")
    if not isinstance(cmds, list):
        return False
    return "cca-roles-hook" in cmds

if not any(has_hook(e) for e in pre):
    pre.append(hook_obj)

settings_path.write_text(json.dumps(data, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
PY

    local code=$?
    if [[ $code -eq 2 ]]; then
        log_warn "Invalid JSON (skipping): $settings"
        return 0
    fi
    if [[ $code -ne 0 ]]; then
        log_warn "Failed to update .claude/settings.json: $settings"
        return 0
    fi
    log_info "Configured PreToolUse hook: $settings"
}

ensure_project_claude_md_policy() {
    local project_root="$1"
    local file="$project_root/CLAUDE.md"
    local start="<!-- CCA_WORKFLOW_POLICY -->"
    local end="<!-- /CCA_WORKFLOW_POLICY -->"

    local block
    block="$(cat <<'MD'
<!-- CCA_WORKFLOW_POLICY -->
## CCA Default Workflow

- All file modifications must use /file-op (delegated to Codex)
- All cross-reviews via /review
- Roles are auto-resolved from: session > project > system > default
<!-- /CCA_WORKFLOW_POLICY -->
MD
)"

    if [[ -f "$file" ]]; then
        if grep -qF "$start" "$file" 2>/dev/null; then
            return 0
        fi
        if [[ ! -w "$file" ]]; then
            log_warn "CLAUDE.md not writable (skipping policy insert): $file"
            return 0
        fi
        {
            echo ""
            echo "$block"
        } >> "$file" || { log_warn "Failed to append policy to CLAUDE.md: $file"; return 0; }
        log_info "Injected CCA workflow policy into: $file"
        return 0
    fi

    # Create CLAUDE.md if missing.
    if ( mkdir -p "$project_root" 2>/dev/null ) && ( touch "$file" 2>/dev/null ); then
        :
    else
        log_warn "Failed to create CLAUDE.md (skipping policy): $file"
        return 0
    fi

    if [[ ! -w "$file" ]]; then
        log_warn "CLAUDE.md not writable (skipping policy create): $file"
        return 0
    fi

    printf "%s\n" "$block" > "$file" || { log_warn "Failed to write CLAUDE.md: $file"; return 0; }
    log_info "Created CLAUDE.md with CCA workflow policy: $file"
}

# Command: version
cmd_version() {
    local install_dir=""
    if install_dir="$(system_install_dir 2>/dev/null)"; then
        :
    else
        install_dir="$CCA_SOURCE"
    fi

    local commit date
    IFS='|' read -r commit date <<< "$(get_installed_version_info "$install_dir")"

    local extra=""
    [[ -n "${commit:-}" ]] && extra="$commit"
    [[ -n "${date:-}" ]] && extra="${extra:+$extra }$date"

    echo "cca v$VERSION${extra:+ $extra}"
    echo "Install/source: $install_dir"

    local remote_commit remote_date
    local remote
    if remote="$(get_remote_version_info 2>/dev/null)"; then
        IFS='|' read -r remote_commit remote_date <<< "$remote"
        if [[ -n "${commit:-}" && -n "${remote_commit:-}" ]]; then
            if [[ "$commit" == "$remote_commit" ]]; then
                echo "Status: up to date"
            else
                echo "Status: update available (${remote_commit}${remote_date:+ $remote_date})"
                echo "Run: cca update"
            fi
        else
            echo "Status: unable to compare versions"
        fi
    else
        echo "Status: unable to check updates (network/curl unavailable)"
    fi
}

# Install to a directory
do_install() {
    local target="$1"
    local type="${2:-project}"
    local install_date="${3:-}"

    [[ "$type" == "project" ]] || type="project"
    update_codex_config "$target" || true

    record_installation "$target" "$type" "${install_date:-}"
    log_info "Configured Codex permissions: $target"
}

# Remove from a directory
do_remove() {
    local target="$1"
    remove_codex_config "$target" || true
    remove_installation "$target"
    log_info "Removed Codex permissions config: $target"
}

# Command: add
cmd_add() {
    local target="$1"

    if [[ -z "$target" ]]; then
        log_error "Usage: cca add <.|path>"
        exit 1
    fi

    case "$target" in
        ".")
            target="$(pwd)"
            log_blue "Configuring current project: $target"
            do_install "$target" "project"
            ensure_system_roles_config || true
            ensure_project_roles_config "$target" || true
            ensure_hook_installed || true
            ensure_claude_settings_hook "$target" || true
            ensure_project_claude_md_policy "$target" || true
            ;;
        *)
            # Resolve path
            if [[ "$target" != /* ]]; then
                target="$(pwd)/$target"
            fi
            target="$(cd "$target" 2>/dev/null && pwd)" || {
                log_error "Directory not found: $target"
                exit 1
            }
            log_blue "Configuring: $target"
            do_install "$target" "project"
            ensure_system_roles_config || true
            ensure_project_roles_config "$target" || true
            ensure_hook_installed || true
            ensure_claude_settings_hook "$target" || true
            ensure_project_claude_md_policy "$target" || true
            ;;
    esac

    echo ""
    log_info "Done! AutoFlow is available globally in ~/.claude/ (run ./install.sh install if needed)."
}

# Command: delete
cmd_delete() {
    local target="$1"

    if [[ -z "$target" ]]; then
        log_error "Usage: cca delete <.|path>"
        exit 1
    fi

    case "$target" in
        ".")
            target="$(pwd)"
            log_blue "Removing config from current project: $target"
            do_remove "$target"
            ;;
        *)
            if [[ "$target" != /* ]]; then
                target="$(pwd)/$target"
            fi
            target="$(cd "$target" 2>/dev/null && pwd)" || {
                log_error "Directory not found: $target"
                exit 1
            }
            log_blue "Removing config from: $target"
            do_remove "$target"
            ;;
    esac
}

# Command: update
cmd_update() {
    local mode="${1:-}"
    require_platform
    local source_root=""

    if [[ "$mode" == "--local" ]]; then
        source_root="$CCA_SOURCE"
        log_blue "Refreshing ~/.claude/ from local source: $source_root"
    else
        local install_dir
        if ! install_dir="$(system_install_dir)"; then
            log_error "System installation not found: $CCA_INSTALL_PREFIX"
            log_error "Run: ./install.sh install"
            exit 1
        fi

        local before_commit before_date before_version
        IFS='|' read -r before_commit before_date <<< "$(get_installed_version_info "$install_dir")"
        before_version="$(get_installed_version_string "$install_dir")"
        local before_head=""
        if command -v git >/dev/null 2>&1 && [[ -d "$install_dir/.git" ]]; then
            before_head="$(git -C "$install_dir" rev-parse HEAD 2>/dev/null || true)"
        fi

        log_blue "Updating system installation: $install_dir"

        if command -v git >/dev/null 2>&1 && [[ -d "$install_dir/.git" ]]; then
            log_blue "Updating via git pull..."
            git -C "$install_dir" pull --ff-only
            log_blue "Syncing binaries after git update..."
            sync_bin_tools "$install_dir" || true
        else
            log_blue "Updating via tarball..."
            (
                set -euo pipefail
                command -v tar >/dev/null 2>&1 || { log_error "tar not found"; exit 1; }

                tmp_dir="$(mktemp -d 2>/dev/null || mktemp -d -t cca_update.XXXXXX)"
                trap 'rm -rf "$tmp_dir"' EXIT

                tarball_url="$CCA_REPO_URL/archive/refs/heads/main.tar.gz"
                tarball_path="$tmp_dir/main.tar.gz"

                if command -v curl >/dev/null 2>&1; then
                    curl -fsSL -o "$tarball_path" "$tarball_url"
                elif command -v wget >/dev/null 2>&1; then
                    wget -q -O "$tarball_path" "$tarball_url"
                else
                    log_error "Missing dependency: curl or wget"
                    exit 1
                fi

                tar -xzf "$tarball_path" -C "$tmp_dir"

                extracted_dir="$tmp_dir/claude_code_autoflow-main"
                if [[ ! -d "$extracted_dir" ]]; then
                    extracted_dir="$(find "$tmp_dir" -maxdepth 1 -type d -name '*-main' -print -quit 2>/dev/null || true)"
                fi
                [[ -d "$extracted_dir" ]] || { log_error "Failed to extract tarball"; exit 1; }

                remote_commit=""
                remote_date=""
                remote="$(get_remote_version_info 2>/dev/null || true)"
                if [[ -n "${remote:-}" ]]; then
                    IFS='|' read -r remote_commit remote_date <<< "$remote"
                fi

                detected_bin_dir="$CCA_BIN_DIR"
                detected_bin_dir="$(dirname "$(command -v cca 2>/dev/null || echo "$CCA_BIN_DIR/cca")")"

                CCA_INSTALL_PREFIX="$install_dir" \
                    CCA_BIN_DIR="$detected_bin_dir" \
                    CCA_GIT_COMMIT="${remote_commit:-}" \
                    CCA_GIT_DATE="${remote_date:-}" \
                    bash "$extracted_dir/install.sh" install
            )
        fi

        local after_commit after_date after_version
        IFS='|' read -r after_commit after_date <<< "$(get_installed_version_info "$install_dir")"
        after_version="$(get_installed_version_string "$install_dir")"
        local after_head=""
        if command -v git >/dev/null 2>&1 && [[ -d "$install_dir/.git" ]]; then
            after_head="$(git -C "$install_dir" rev-parse HEAD 2>/dev/null || true)"
        fi

        local version_changed=1
        if [[ -n "${before_commit:-}" && -n "${after_commit:-}" && "$before_commit" == "$after_commit" ]]; then
            log_info "cca already up to date ($after_version)"
            version_changed=0
        else
            log_info "cca updated: ${before_version} -> ${after_version}"
            if [[ -n "${before_head:-}" && -n "${after_head:-}" && "$before_head" != "$after_head" ]]; then
                log_blue "Recent changes:"
                git -C "$install_dir" log --oneline -5 "${before_head}..${after_head}" 2>/dev/null | sed 's/^/  /' || true
            fi
        fi

        CCA_SOURCE="$install_dir"
        source_root="$install_dir"
        if [[ "$version_changed" -eq 1 ]]; then
            log_info "Updated system installation"
        else
            log_info "System installation already up to date"
        fi
    fi

    # Refresh globally visible skills/commands in ~/.claude/
    install_global_skills "$source_root"

    local -a _install_lines=()
    mapfile -t _install_lines < "$INSTALLATIONS_FILE" 2>/dev/null || true

    local count=0
    for line in "${_install_lines[@]+"${_install_lines[@]}"}"; do
        [[ -z "${line//[[:space:]]/}" ]] && continue
        IFS='|' read -r path type date <<< "$line"
        [[ -z "${path:-}" ]] && continue
        if [[ -d "$path" ]]; then
            log_blue "Refreshing project config: $path"
            do_install "$path" "${type:-project}" "${date:-}"
            ensure_claude_settings_hook "$path" || true
            ensure_project_claude_md_policy "$path" || true
            ((count+=1))
        else
            log_warn "Skipping (not found): $path"
            remove_installation "$path"
        fi
    done

    echo ""
    log_info "Updated $count project(s)"
}

# Command: list
cmd_list() {
    log_blue "Configured projects:"
    echo ""

    # Check if file has any non-whitespace content
    if ! grep -q '[^[:space:]]' "$INSTALLATIONS_FILE" 2>/dev/null; then
        echo "  (none)"
        return
    fi

    printf "  %-50s %-10s %s\n" "PATH" "TYPE" "DATE"
    printf "  %-50s %-10s %s\n" "----" "----" "----"

    while IFS='|' read -r path type date; do
        [[ -z "$path" ]] && continue
        local status=""
        if codex_project_configured "$path"; then
            status="${GREEN}✓${NC}"
        else
            status="${RED}✗${NC}"
        fi
        printf "  %-50s %-10s %s %b\n" "$path" "$type" "$date" "$status"
    done < "$INSTALLATIONS_FILE"
}

# Command: uninstall
cmd_uninstall() {
    log_warn "This will remove cca from your system."
    echo ""
    read -p "Remove all configured project entries from Codex config too? [y/N] " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Remove all configured projects (best effort).
        local -a _install_lines=()
        mapfile -t _install_lines < "$INSTALLATIONS_FILE" 2>/dev/null || true
        for line in "${_install_lines[@]+"${_install_lines[@]}"}"; do
            [[ -z "${line//[[:space:]]/}" ]] && continue
            IFS='|' read -r path type date <<< "$line"
            [[ -z "${path:-}" ]] && continue
            do_remove "$path" || true
        done
    fi

    # Remove cca binary
    local cca_path="$(which cca 2>/dev/null)"
    if [[ -n "$cca_path" ]] && [[ -f "$cca_path" ]]; then
        rm -f "$cca_path"
        log_info "Removed: $cca_path"
    fi

    # Remove system install copy
    local install_dir=""
    if install_dir="$(system_install_dir 2>/dev/null)"; then
        rm -rf "$install_dir" 2>/dev/null || true
        log_info "Removed: $install_dir"
    fi

    # Remove cca config
    rm -rf "$CCA_HOME"
    log_info "Removed: $CCA_HOME"

    echo ""
    log_info "cca uninstalled. Goodbye!"
}

# Main
case "${1:-}" in
    add)
        cmd_add "$2"
        ;;
    delete|remove|rm)
        cmd_delete "$2"
        ;;
    update|upgrade)
        cmd_update "${2:-}"
        ;;
    list|ls)
        cmd_list
        ;;
    uninstall)
        cmd_uninstall
        ;;
    version|-v|--version)
        cmd_version
        ;;
    help|-h|--help|"")
        usage
        ;;
    *)
        log_error "Unknown command: $1"
        echo "Run 'cca help' for usage."
        exit 1
        ;;
esac
