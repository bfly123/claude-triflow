#!/bin/bash
# cca - Claude Code AutoFlow CLI
# Manage AutoFlow skill installations across projects

set -euo pipefail
shopt -s nullglob

VERSION="1.8.0"
GIT_COMMIT=""
GIT_DATE=""

CCA_HOME="${CCA_HOME:-${XDG_CONFIG_HOME:-$HOME/.config}/cca}"
CCA_CACHE="${CCA_CACHE:-${XDG_CACHE_HOME:-$HOME/.cache}/cca}"
CCA_INSTALL_PREFIX="${CCA_INSTALL_PREFIX:-$HOME/.local/share/cca}"
CCA_BIN_DIR="${CCA_BIN_DIR:-$HOME/.local/bin}"

CCA_REPO_GIT="https://github.com/bfly123/claude_code_autoflow.git"
CCA_REPO_URL="${CCA_REPO_GIT%.git}"
CCA_REPO_API="https://api.github.com/repos/bfly123/claude_code_autoflow/commits/main"
INSTALLATIONS_FILE="$CCA_HOME/installations"

resolve_script_path() {
    local src="$1"
    while [[ -L "$src" ]]; do
        local dir
        dir="$(cd -P "$(dirname "$src")" && pwd)"
        src="$(readlink "$src")"
        [[ "$src" != /* ]] && src="$dir/$src"
    done
    local dir
    dir="$(cd -P "$(dirname "$src")" && pwd)"
    echo "$dir/$(basename "$src")"
}

CCA_SCRIPT_PATH="$(resolve_script_path "${BASH_SOURCE[0]}")"
CCA_SCRIPT_ROOT="$(cd "$(dirname "$CCA_SCRIPT_PATH")" && pwd)"

# Default source path:
# - env CCA_SOURCE (if set)
# - resolved script directory (symlink-aware)
CCA_SOURCE="${CCA_SOURCE:-$CCA_SCRIPT_ROOT}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Ensure CCA_HOME and cache exist
mkdir -p "$CCA_HOME" "$CCA_CACHE"
touch "$INSTALLATIONS_FILE"

usage() {
    cat << EOF
cca - Claude Code AutoFlow CLI v$VERSION

Usage: cca <command> [options]

Commands:
  add .          Configure Codex permissions for current project
  add <path>     Configure Codex permissions for a project

  delete .       Remove Codex permissions config for current project
  delete <path>  Remove Codex permissions config for a project

  update [--local] [--no-reexec]  Update cca and refresh projects
  list           Show configured projects
  uninstall      Remove cca from system

  version        Show version and commit info
  help           Show this help

Examples:
  cca add .                  # Configure current project
  cca add ~/myproject        # Configure a project
  cca delete .               # Remove config from current project
  cca update                 # Update cca and refresh configured projects
  cca update --local         # Refresh configured projects from current CCA_SOURCE
  cca update --no-reexec     # Do not re-exec into the updated cca

Config:
  CCA_HOME=$CCA_HOME
  CCA_INSTALL_PREFIX=$CCA_INSTALL_PREFIX
  CCA_SOURCE=$CCA_SOURCE
EOF
}

log_info() { printf "${GREEN}[+]${NC} %s\n" "$1"; }
log_warn() { printf "${YELLOW}[!]${NC} %s\n" "$1"; }
log_error() { printf "${RED}[-]${NC} %s\n" "$1"; }
log_blue() { printf "${BLUE}[*]${NC} %s\n" "$1"; }

AUTOFLOW_SKILLS=(tr tp dual-design file-op ask-codex ask-gemini roles review mode-switch docs)
AUTOFLOW_COMMANDS=(tr.md tp.md dual-design.md file-op.md ask-codex.md ask-gemini.md roles.md review.md mode-switch.md auto.md)

detect_platform() {
    local name
    name="$(uname -s 2>/dev/null || echo unknown)"
    case "$name" in
        Linux) echo "linux" ;;
        Darwin) echo "macos" ;;
        *) echo "unknown" ;;
    esac
}

require_platform() {
    local p
    p="$(detect_platform)"
    if [[ "$p" != "linux" && "$p" != "macos" ]]; then
        log_error "Unsupported platform: $(uname -s 2>/dev/null || echo unknown) (Linux/macOS only)"
        exit 1
    fi
}

sed_inplace() {
    # Portable in-place edit for GNU sed and BSD/macOS sed.
    # Usage: sed_inplace 's/old/new/' file
    local script="$1"
    local file="$2"
    sed -i.bak "$script" "$file"
    rm -f "${file}.bak"
}

toml_escape_basic() {
    # Escape backslashes and double quotes for TOML basic strings.
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//\"/\\\"}"
    printf "%s" "$s"
}

update_codex_config() {
    local target_path="$1"
    local codex_cfg="$HOME/.codex/config.toml"

    if [[ ! -f "$codex_cfg" ]]; then
        log_warn "Codex config not found: $codex_cfg (skipping auto-approval setup)"
        return 0
    fi
    if [[ ! -w "$codex_cfg" ]]; then
        log_warn "Codex config not writable: $codex_cfg (skipping auto-approval setup)"
        return 0
    fi

    local escaped_path
    escaped_path="$(toml_escape_basic "$target_path")"
    local header="[projects.\"$escaped_path\"]"

    local tmp
    tmp="$(mktemp "${CCA_HOME}/codex-config.tmp.XXXXXX")"

    if grep -Fq -- "$header" "$codex_cfg"; then
        # Ensure approval_policy = "never" exists within this project section.
        awk -v header="$header" '
            function print_approval() { print "approval_policy = \"never\"" }
            BEGIN { in_section = 0; found = 0 }
            {
                line = $0
                if (line ~ /^\[[^]]+\]$/) {
                    if (in_section == 1) {
                        if (found == 0) print_approval()
                        in_section = 0
                    }
                    if (line == header) {
                        in_section = 1
                        found = 0
                        print line
                        next
                    }
                }
                if (in_section == 1 && line ~ /^[[:space:]]*approval_policy[[:space:]]*=/) {
                    print_approval()
                    found = 1
                    next
                }
                print line
            }
            END {
                if (in_section == 1 && found == 0) print_approval()
            }
        ' "$codex_cfg" > "$tmp" || { rm -f "$tmp"; log_warn "Failed to update Codex config (parse error): $codex_cfg"; return 0; }
        if ( cat "$tmp" > "$codex_cfg" ) 2>/dev/null; then
            rm -f "$tmp"
            log_info "Codex auto-approval ensured (approval_policy=never): $target_path"
        else
            rm -f "$tmp"
            log_warn "Failed to update Codex config (write denied): $codex_cfg"
        fi
        return 0
    fi

    # Append new project config block.
    cat "$codex_cfg" > "$tmp" || { rm -f "$tmp"; log_warn "Failed to read Codex config: $codex_cfg"; return 0; }
    {
        echo ""
        echo "$header"
        echo "trust_level = \"trusted\""
        echo "approval_policy = \"never\""
        echo "sandbox_mode = \"full-auto\""
    } >> "$tmp"
    if ( cat "$tmp" > "$codex_cfg" ) 2>/dev/null; then
        rm -f "$tmp"
        log_info "Codex auto-approval configured for project: $target_path"
    else
        rm -f "$tmp"
        log_warn "Failed to update Codex config (write denied): $codex_cfg"
    fi
}

remove_codex_config() {
    local target_path="$1"
    local codex_cfg="$HOME/.codex/config.toml"

    if [[ ! -f "$codex_cfg" ]]; then
        log_warn "Codex config not found: $codex_cfg (skipping removal)"
        return 0
    fi
    if [[ ! -w "$codex_cfg" ]]; then
        log_warn "Codex config not writable: $codex_cfg (skipping removal)"
        return 0
    fi

    local escaped_path
    escaped_path="$(toml_escape_basic "$target_path")"
    local header="[projects.\"$escaped_path\"]"

    if ! grep -Fq -- "$header" "$codex_cfg" 2>/dev/null; then
        log_warn "Codex project config not found (already removed): $target_path"
        return 0
    fi

    local tmp
    tmp="$(mktemp "${CCA_HOME}/codex-config.tmp.XXXXXX")"

    awk -v header="$header" '
        BEGIN { skip = 0 }
        {
            line = $0
            if (line ~ /^\[[^]]+\]$/) {
                if (skip == 1) skip = 0
                if (line == header) { skip = 1; next }
            }
            if (skip == 1) next
            print line
        }
    ' "$codex_cfg" > "$tmp" || { rm -f "$tmp"; log_warn "Failed to update Codex config (parse error): $codex_cfg"; return 0; }

    if ( cat "$tmp" > "$codex_cfg" ) 2>/dev/null; then
        rm -f "$tmp"
        log_info "Codex project config removed: $target_path"
    else
        rm -f "$tmp"
        log_warn "Failed to update Codex config (write denied): $codex_cfg"
    fi
}

codex_project_configured() {
    local target_path="$1"
    local codex_cfg="$HOME/.codex/config.toml"
    [[ -f "$codex_cfg" ]] || return 1

    local escaped_path
    escaped_path="$(toml_escape_basic "$target_path")"
    local header="[projects.\"$escaped_path\"]"
    grep -Fq -- "$header" "$codex_cfg" 2>/dev/null
}

canonical_path() {
    # Prefer realpath; fall back to Python for portability.
    local p="$1"
    if command -v realpath >/dev/null 2>&1; then
        realpath "$p"
        return 0
    fi
    python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$p"
}

system_install_dir() {
    if [[ -d "$CCA_INSTALL_PREFIX" && -f "$CCA_INSTALL_PREFIX/cca" && -f "$CCA_INSTALL_PREFIX/install.sh" ]]; then
        echo "$CCA_INSTALL_PREFIX"
        return 0
    fi
    return 1
}

get_local_version_info() {
    local dir="$1"
    local commit="$GIT_COMMIT"
    local date="$GIT_DATE"

    if [[ -z "${commit:-}" ]] && command -v git >/dev/null 2>&1 && [[ -d "$dir/.git" ]]; then
        commit="$(git -C "$dir" log -1 --format='%h' 2>/dev/null || true)"
        date="$(git -C "$dir" log -1 --format='%cs' 2>/dev/null || true)"
    fi

    printf "%s|%s\n" "${commit:-}" "${date:-}"
}

get_installed_version_info() {
    # Best-effort version read for an installed directory.
    # Prefer git metadata when available; fall back to reading injected variables from cca file.
    local dir="$1"
    local commit=""
    local date=""

    if command -v git >/dev/null 2>&1 && [[ -d "$dir/.git" ]]; then
        commit="$(git -C "$dir" rev-parse --short HEAD 2>/dev/null || true)"
        date="$(git -C "$dir" log -1 --format='%cs' 2>/dev/null || true)"
        printf "%s|%s\n" "${commit:-}" "${date:-}"
        return 0
    fi

    if [[ -f "$dir/cca" ]]; then
        # Accept either single or double quotes; ignore trailing whitespace.
        commit="$(grep -E '^GIT_COMMIT=' "$dir/cca" 2>/dev/null | head -1 | sed -E 's/^GIT_COMMIT=//; s/[[:space:]]+$//; s/^"//; s/"$//; s/^'\''//; s/'\''$//' 2>/dev/null || true)"
        date="$(grep -E '^GIT_DATE=' "$dir/cca" 2>/dev/null | head -1 | sed -E 's/^GIT_DATE=//; s/[[:space:]]+$//; s/^"//; s/"$//; s/^'\''//; s/'\''$//' 2>/dev/null || true)"
    fi

    printf "%s|%s\n" "${commit:-}" "${date:-}"
}

get_installed_version_string() {
    local dir="$1"
    local commit date
    IFS='|' read -r commit date <<< "$(get_installed_version_info "$dir")"

    if [[ -z "${commit:-}" && -z "${date:-}" ]]; then
        printf "%s\n" "(unknown)"
        return 0
    fi

    if [[ -n "${commit:-}" && -n "${date:-}" ]]; then
        printf "%s %s\n" "$commit" "$date"
        return 0
    fi

    printf "%s\n" "${commit:-${date:-}}"
}

get_remote_version_info() {
    command -v curl >/dev/null 2>&1 || command -v wget >/dev/null 2>&1 || return 1
    local api_response commit date
    if command -v curl >/dev/null 2>&1; then
        api_response="$(curl -fsSL "$CCA_REPO_API" 2>/dev/null || true)"
    else
        api_response="$(wget -q -O - "$CCA_REPO_API" 2>/dev/null || true)"
    fi
    [[ -n "$api_response" ]] || return 1

    commit="$(echo "$api_response" | grep -o '"sha": "[^"]*"' | head -1 | cut -d'"' -f4 | cut -c1-7)"
    date="$(echo "$api_response" | grep -o '"date": "[^"]*"' | head -1 | cut -d'"' -f4 | cut -c1-10)"
    [[ -n "${commit:-}" ]] || return 1
    printf "%s|%s\n" "${commit:-}" "${date:-}"
}

# Record installation path
record_installation() {
    local path="$1"
    local type="$2"  # project or system
    local install_date="${3:-$(date +%Y-%m-%d)}"
    # Remove existing entry if any
    local tmp
    tmp="$(mktemp "${INSTALLATIONS_FILE}.tmp.XXXXXX")"
    grep -Fv -- "$path|" "$INSTALLATIONS_FILE" > "$tmp" 2>/dev/null || true
    mv "$tmp" "$INSTALLATIONS_FILE"
    # Add new entry with trailing newline
    printf "%s|%s|%s\n" "$path" "$type" "$install_date" >> "$INSTALLATIONS_FILE"
}

# Remove installation record
remove_installation() {
    local path="$1"
    local tmp
    tmp="$(mktemp "${INSTALLATIONS_FILE}.tmp.XXXXXX")"
    grep -Fv -- "$path|" "$INSTALLATIONS_FILE" > "$tmp" 2>/dev/null || true
    mv "$tmp" "$INSTALLATIONS_FILE"
}

# Check source files exist (for project-local install)
check_source_dir() {
    local source_root="${1:-$CCA_SOURCE}"
    if [[ ! -d "$source_root/claude_source/skills" ]]; then
        log_error "Skills not found in $source_root/claude_source/skills/"
        log_error "Set CCA_SOURCE to your AutoFlow repository directory"
        exit 1
    fi
    if [[ ! -d "$source_root/claude_source/commands" ]]; then
        log_error "Commands not found in $source_root/claude_source/commands/"
        exit 1
    fi

    for skill in "${AUTOFLOW_SKILLS[@]}"; do
        if [[ ! -d "$source_root/claude_source/skills/$skill" ]]; then
            log_error "Missing AutoFlow skill in source: $source_root/claude_source/skills/$skill"
            exit 1
        fi
    done
}

detect_legacy_global() {
    local target="$HOME/.claude"
    local skills_dir="$target/skills"

    for skill in "${AUTOFLOW_SKILLS[@]}"; do
        if [[ -d "$skills_dir/$skill" ]]; then
            return 0
        fi
    done

    local roles_cfg="${XDG_CONFIG_HOME:-$HOME/.config}/cca/roles.json"
    if [[ -f "$roles_cfg" ]]; then
        return 0
    fi

    return 1
}

cleanup_legacy_global() {
    local target="$HOME/.claude"
    local skills_dir="$target/skills"
    local commands_dir="$target/commands"

    # Skills
    for skill in "${AUTOFLOW_SKILLS[@]}"; do
        rm -rf "$skills_dir/$skill" 2>/dev/null || true
    done

    # Commands: only those listed in .cca-owned
    local owned="$commands_dir/.cca-owned"
    if [[ -f "$owned" ]]; then
        while IFS= read -r name; do
            [[ -z "${name//[[:space:]]/}" ]] && continue
            rm -f "$commands_dir/$name" 2>/dev/null || true
        done < "$owned"
        rm -f "$owned" 2>/dev/null || true
    fi

    # Roles config: backup and remove (legacy system config)
    local roles_cfg="${XDG_CONFIG_HOME:-$HOME/.config}/cca/roles.json"
    if [[ -f "$roles_cfg" ]]; then
        local backup_dir
        backup_dir="$(dirname "$roles_cfg")/backup"
        mkdir -p "$backup_dir" 2>/dev/null || true
        local ts
        ts="$(date +%Y%m%d%H%M%S 2>/dev/null || echo now)"
        if mv -f "$roles_cfg" "$backup_dir/roles.json.$ts" 2>/dev/null; then
            log_info "Backed up legacy system roles: $backup_dir/roles.json.$ts"
        else
            rm -f "$roles_cfg" 2>/dev/null || true
            log_info "Removed legacy system roles: $roles_cfg"
        fi
    fi

    log_info "Cleaned legacy global AutoFlow config (~/.claude, ~/.config/cca)"
}

ensure_project_roles_config() {
    local project_root="$1"
    local target_dir="$project_root/.autoflow"
    local target_file="$target_dir/roles.json"
    local template="$CCA_SOURCE/claude_source/templates/roles.json"

    if [[ -f "$target_file" ]]; then
        log_warn "Project roles config already exists: $target_file"
        return 0
    fi

    mkdir -p "$target_dir" 2>/dev/null || true
    if [[ -f "$template" ]]; then
        if cp -n "$template" "$target_file" 2>/dev/null; then
            :
        else
            cp "$template" "$target_file"
        fi
        log_info "Installed project roles config: $target_file"
    else
        log_warn "Roles template not found (skipping): $template"
    fi
}

ensure_project_skills() {
    local project_root="$1"
    local source_root="${2:-$CCA_SOURCE}"

    local src_skills="$source_root/claude_source/skills"
    local src_commands="$source_root/claude_source/commands"
    if [[ ! -d "$src_skills" || ! -d "$src_commands" ]]; then
        log_warn "Skills/commands source not found (skipping project install): $source_root/claude_source/"
        return 0
    fi

    local claude_dir="$project_root/.claude"
    local skills_dir="$claude_dir/skills"
    local commands_dir="$claude_dir/commands"

    mkdir -p "$skills_dir" "$commands_dir" 2>/dev/null || true
    if [[ ! -d "$claude_dir" || ! -w "$claude_dir" ]]; then
        log_warn "Project .claude/ not writable (skipping skills install): $claude_dir"
        return 0
    fi

    for skill in "${AUTOFLOW_SKILLS[@]}"; do
        if [[ -d "$src_skills/$skill" ]]; then
            rm -rf "$skills_dir/$skill" 2>/dev/null || true
            cp -a "$src_skills/$skill" "$skills_dir/" 2>/dev/null || true
        fi
    done

    local owned="$commands_dir/.cca-owned"
    if [[ -f "$owned" ]]; then
        while IFS= read -r name; do
            [[ -z "${name//[[:space:]]/}" ]] && continue
            rm -f "$commands_dir/$name" 2>/dev/null || true
        done < "$owned"
    fi

    : > "$owned" 2>/dev/null || true
    for cmd in "${AUTOFLOW_COMMANDS[@]}"; do
        if [[ -f "$src_commands/$cmd" ]]; then
            cp -a "$src_commands/$cmd" "$commands_dir/" 2>/dev/null || true
            printf "%s\n" "$cmd" >> "$owned" 2>/dev/null || true
        fi
    done

    # Convert global skill paths to project-local paths.
    while IFS= read -r f; do
        [[ -f "$f" ]] || continue
        if grep -qF '~/.claude/skills/' "$f" 2>/dev/null; then
            sed_inplace 's#~/.claude/skills/#.claude/skills/#g' "$f"
        fi
    done < <(find "$claude_dir" -type f \( -name '*.md' -o -name '*.json' -o -name '*.sh' -o -name '*.py' \) -print 2>/dev/null || true)

    log_info "Installed project skills/commands: $claude_dir"
}

remove_project_skills() {
    local project_root="$1"
    local claude_dir="$project_root/.claude"
    local skills_dir="$claude_dir/skills"
    local commands_dir="$claude_dir/commands"

    if [[ ! -d "$claude_dir" ]]; then
        return 0
    fi

    # Skills: remove only CCA-managed skill folders.
    for skill in "${AUTOFLOW_SKILLS[@]}"; do
        rm -rf "$skills_dir/$skill" 2>/dev/null || true
    done

    # Commands: remove only CCA-managed command wrappers.
    local owned="$commands_dir/.cca-owned"
    if [[ -f "$owned" ]]; then
        while IFS= read -r name; do
            [[ -z "${name//[[:space:]]/}" ]] && continue
            rm -f "$commands_dir/$name" 2>/dev/null || true
        done < "$owned"
        rm -f "$owned" 2>/dev/null || true
    else
        for f in "$commands_dir"/*.md; do
            [[ -f "$f" ]] || continue
            if grep -qF '.claude/skills/' "$f" 2>/dev/null; then
                if grep -Eq '\.claude/skills/(tr|tp|dual-design|file-op|ask-codex|ask-gemini|roles|review|mode-switch|docs)/' "$f" 2>/dev/null; then
                    rm -f "$f" 2>/dev/null || true
                fi
            fi
        done
    fi

    log_info "Removed project skills/commands (cca-managed): $claude_dir"
}

remove_project_hook() {
    local project_root="$1"
    local settings="$project_root/.claude/settings.json"

    if [[ ! -f "$settings" ]]; then
        return 0
    fi

    python3 - "$settings" <<'PY'
import json
import sys
from pathlib import Path

path = Path(sys.argv[1])
try:
    data = json.loads(path.read_text(encoding="utf-8"))
except Exception:
    sys.exit(2)

if not isinstance(data, dict):
    sys.exit(2)

hooks = data.get("hooks")
if not isinstance(hooks, dict):
    sys.exit(0)

pre = hooks.get("PreToolUse")
if not isinstance(pre, list):
    sys.exit(0)

changed = False
new_pre = []
for e in pre:
    if isinstance(e, dict):
        if isinstance(e.get("commands"), list):
            old_cmds = e.get("commands")
            new_cmds = [c for c in old_cmds if not (isinstance(c, str) and c == "cca-roles-hook")]
            if new_cmds != old_cmds:
                changed = True
            if new_cmds:
                e["commands"] = new_cmds
                new_pre.append(e)
            else:
                changed = True
            continue

        hs = e.get("hooks")
        if isinstance(hs, list):
            old_hs = hs
            new_hs = []
            for h in old_hs:
                if isinstance(h, dict) and h.get("type") == "command" and h.get("command") == "cca-roles-hook":
                    changed = True
                    continue
                new_hs.append(h)
            if new_hs:
                e["hooks"] = new_hs
                new_pre.append(e)
            else:
                changed = True
            continue

    new_pre.append(e)

if new_pre != pre:
    hooks["PreToolUse"] = new_pre

if isinstance(hooks.get("PreToolUse"), list) and len(hooks["PreToolUse"]) == 0:
    hooks.pop("PreToolUse", None)
    changed = True

if changed:
    path.write_text(json.dumps(data, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
PY

    local code=$?
    if [[ $code -eq 2 ]]; then
        log_warn "Invalid JSON (skipping): $settings"
        return 0
    fi
    if [[ $code -ne 0 ]]; then
        log_warn "Failed to update .claude/settings.json: $settings"
        return 0
    fi

    log_info "Removed project PreToolUse hook entry: $settings"
}

remove_claude_md_policy() {
    local project_root="$1"
    local file="$project_root/CLAUDE.md"

    if [[ ! -f "$file" ]]; then
        return 0
    fi

    python3 - "$file" <<'PY'
import re
import sys
from pathlib import Path

path = Path(sys.argv[1])
text = path.read_text(encoding="utf-8", errors="replace")
pattern = re.compile(r"\n?<!-- CCA_WORKFLOW_POLICY -->.*?<!-- /CCA_WORKFLOW_POLICY -->\n?", re.S)
updated, n = pattern.subn("\n", text, count=1)
if n == 0:
    sys.exit(0)
updated = re.sub(r"\n{3,}", "\n\n", updated)
if not updated.endswith("\n"):
    updated += "\n"
path.write_text(updated, encoding="utf-8")
PY

    local code=$?
    if [[ $code -ne 0 ]]; then
        log_warn "Failed to update CLAUDE.md: $file"
        return 0
    fi

    log_info "Removed CCA workflow policy block: $file"
}

ensure_hook_installed() {
    local bin_dir="$CCA_BIN_DIR"
    bin_dir="$(dirname "$(command -v cca 2>/dev/null || echo "$CCA_BIN_DIR/cca")")"
    local src="$CCA_SOURCE/cca-roles-hook"
    local dst="$bin_dir/cca-roles-hook"

    if [[ ! -f "$src" ]]; then
        log_warn "Hook script not found (skipping install): $src"
        return 0
    fi

    mkdir -p "$bin_dir" 2>/dev/null || true
    if cp -f "$src" "$dst" 2>/dev/null; then
        chmod +x "$dst" 2>/dev/null || true
        log_info "Installed hook: $dst"
    else
        log_warn "Failed to install hook to: $dst (permission denied?)"
    fi
}

sync_bin_tools() {
    # Ensure cca and helper scripts are present in bin dir (needed after git-based update).
    local install_dir="$1"
    local bin_dir="$CCA_BIN_DIR"
    bin_dir="$(dirname "$(command -v cca 2>/dev/null || echo "$CCA_BIN_DIR/cca")")"

    mkdir -p "$bin_dir" 2>/dev/null || true

    if [[ -f "$install_dir/cca" ]]; then
        chmod +x "$install_dir/cca" 2>/dev/null || true
        if ln -sf "$install_dir/cca" "$bin_dir/cca" 2>/dev/null; then
            :
        else
            cp -f "$install_dir/cca" "$bin_dir/cca" 2>/dev/null || true
            chmod +x "$bin_dir/cca" 2>/dev/null || true
        fi
        log_info "Synced: $bin_dir/cca"
    else
        log_warn "Missing installed cca (skipping bin sync): $install_dir/cca"
    fi

    if [[ -f "$install_dir/cca-roles-hook" ]]; then
        chmod +x "$install_dir/cca-roles-hook" 2>/dev/null || true
        if ln -sf "$install_dir/cca-roles-hook" "$bin_dir/cca-roles-hook" 2>/dev/null; then
            :
        else
            cp -f "$install_dir/cca-roles-hook" "$bin_dir/cca-roles-hook" 2>/dev/null || true
            chmod +x "$bin_dir/cca-roles-hook" 2>/dev/null || true
        fi
        log_info "Synced: $bin_dir/cca-roles-hook"
    else
        log_warn "Missing hook script in install dir (skipping bin sync): $install_dir/cca-roles-hook"
    fi
}

ensure_claude_settings_hook() {
    local project_root="$1"
    local claude_dir="$project_root/.claude"
    local settings="$claude_dir/settings.json"

    mkdir -p "$claude_dir" 2>/dev/null || true

    # Merge/update JSON safely via python. If invalid JSON, skip to avoid clobbering.
    python3 - "$settings" <<'PY'
import json, os, sys
from pathlib import Path

settings_path = Path(sys.argv[1])
hook_obj = {
    "matcher": ".*",
    "hooks": [{"type": "command", "command": "cca-roles-hook"}],
}

data = {}
if settings_path.exists():
    try:
        data = json.loads(settings_path.read_text(encoding="utf-8"))
        if not isinstance(data, dict):
            raise ValueError("settings.json is not an object")
    except Exception:
        # Do not overwrite unknown/invalid config.
        sys.exit(2)

hooks = data.get("hooks")
if not isinstance(hooks, dict):
    hooks = {}
    data["hooks"] = hooks

pre = hooks.get("PreToolUse")
if not isinstance(pre, list):
    pre = []
    hooks["PreToolUse"] = pre

def is_new_format_hook(entry: dict) -> bool:
    hs = entry.get("hooks")
    if not isinstance(hs, list):
        return False
    for h in hs:
        if not isinstance(h, dict):
            continue
        if h.get("type") == "command" and h.get("command") == "cca-roles-hook":
            return True
    return False

def matcher_to_str(matcher) -> str:
    if isinstance(matcher, str) and matcher:
        return matcher
    if isinstance(matcher, dict):
        tools = matcher.get("tools")
        if isinstance(tools, list):
            for t in tools:
                if isinstance(t, str) and t:
                    return t
        tool = matcher.get("tool")
        if isinstance(tool, str) and tool:
            return tool
    return ".*"

def migrate_old_entry(entry: dict) -> dict:
    # Best-effort migration from legacy:
    # {"matcher": ".*", "commands": ["cca-roles-hook", ...]}
    new_matcher = matcher_to_str(entry.get("matcher"))

    cmds = entry.get("commands")
    new_hooks = []
    if isinstance(cmds, list):
        for c in cmds:
            if isinstance(c, str) and c:
                new_hooks.append({"type": "command", "command": c})
    else:
        new_hooks.append({"type": "command", "command": "cca-roles-hook"})

    return {"matcher": new_matcher, "hooks": new_hooks}

# 1) If legacy entries exist, migrate them (preserve other commands in that entry).
migrated = []
changed = False
for e in pre:
    if isinstance(e, dict) and "commands" in e:
        migrated.append(migrate_old_entry(e))
        changed = True
    else:
        migrated.append(e)
pre[:] = migrated

# 2) Ensure CCA hook exists in new format (idempotent).
for e in pre:
    if isinstance(e, dict) and is_new_format_hook(e):
        m = e.get("matcher")
        m_str = matcher_to_str(m)
        if m != m_str:
            e["matcher"] = m_str
            changed = True

if not any(is_new_format_hook(e) for e in pre if isinstance(e, dict)):
    pre.append(hook_obj)
    changed = True

if changed or not settings_path.exists():
    settings_path.write_text(json.dumps(data, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
PY

    local code=$?
    if [[ $code -eq 2 ]]; then
        log_warn "Invalid JSON (skipping): $settings"
        return 0
    fi
    if [[ $code -ne 0 ]]; then
        log_warn "Failed to update .claude/settings.json: $settings"
        return 0
    fi
    log_info "Configured PreToolUse hook: $settings"
}

ensure_project_claude_md_policy() {
    local project_root="$1"
    local file="$project_root/CLAUDE.md"
    local start="<!-- CCA_WORKFLOW_POLICY -->"
    local end="<!-- /CCA_WORKFLOW_POLICY -->"

	    local block
	    block=$(cat <<'MD'
<!-- CCA_WORKFLOW_POLICY -->
## CCA Workflow Policy

### Claude's Role (CRITICAL)
**Claude is the MANAGER, not the executor.**
- Plan and coordinate tasks
- Check role assignments before ANY action
- Delegate to appropriate executor (cask/oask/gask)
- NEVER execute file modifications directly

### Role-Based Delegation
| Role | Scope | Delegate |
|------|-------|----------|
| executor | Write/Edit, file-changing Bash | cask/oask |
| searcher | WebSearch/WebFetch | cask/oask/gask |
| git_manager | git add/commit/push/merge | cask/oask/gask |

### Commands
- codex: cask "task"
- opencode: oask "task"  
- gemini: gask "task"

### Rules
### Rules (MANDATORY)
1. If role ≠ claude, delegate IMMEDIATELY without asking user
2. DO NOT ask user to choose execution method - auto-delegate based on role
3. DO NOT offer options like "委托给 Codex" or "直接执行"
4. Allowed direct: Read, Grep, Glob, .autoflow/**, /tmp/**
<!-- /CCA_WORKFLOW_POLICY -->
MD
)

    if [[ ! -f "$file" ]]; then
        # Create CLAUDE.md if missing.
        if ( mkdir -p "$project_root" 2>/dev/null ) && ( touch "$file" 2>/dev/null ); then
            :
        else
            log_warn "Failed to create CLAUDE.md (skipping policy): $file"
            return 0
        fi

        if [[ ! -w "$file" ]]; then
            log_warn "CLAUDE.md not writable (skipping policy create): $file"
            return 0
        fi

        printf "%s\n" "$block" > "$file" || { log_warn "Failed to write CLAUDE.md: $file"; return 0; }
        log_info "Created CLAUDE.md with CCA workflow policy: $file"
        return 0
    fi

    if [[ ! -w "$file" ]]; then
        log_warn "CLAUDE.md not writable (skipping policy update): $file"
        return 0
    fi

	    if grep -qF "$start" "$file" 2>/dev/null; then
	        # Replace existing policy block (idempotent update).
	        if python3 - "$file" <<-'PY'
	import re
	import sys
	from pathlib import Path
	
	path = Path(sys.argv[1])
	text = path.read_text(encoding="utf-8", errors="replace")
	
	new_block = """<!-- CCA_WORKFLOW_POLICY -->
	## CCA Workflow Policy
	
	### Claude's Role (CRITICAL)
	**Claude is the MANAGER, not the executor.**
	- Plan and coordinate tasks
	- Check role assignments before ANY action
	- Delegate to appropriate executor (cask/oask/gask)
	- NEVER execute file modifications directly
	
	### Role-Based Delegation
	| Role | Scope | Delegate |
	|------|-------|----------|
	| executor | Write/Edit, file-changing Bash | cask/oask |
	| searcher | WebSearch/WebFetch | cask/oask/gask |
	| git_manager | git add/commit/push/merge | cask/oask/gask |
	
	### Commands
	- codex: cask "task"
	- opencode: oask "task"  
	- gemini: gask "task"
	
	### Rules (MANDATORY)
	1. If role ≠ claude, delegate IMMEDIATELY without asking user
	2. DO NOT ask user to choose execution method - auto-delegate based on role
	3. DO NOT offer options like "委托给 Codex" or "直接执行"
	4. Allowed direct: Read, Grep, Glob, .autoflow/**, /tmp/**
	<!-- /CCA_WORKFLOW_POLICY -->"""

pattern = re.compile(r"<!-- CCA_WORKFLOW_POLICY -->.*?<!-- /CCA_WORKFLOW_POLICY -->", re.S)
updated, n = pattern.subn(new_block, text, count=1)
if n == 0:
    sys.exit(4)

if updated != text:
    if not updated.endswith("\n"):
        updated += "\n"
    path.write_text(updated, encoding="utf-8")
PY
        then
            log_info "Updated CCA workflow policy in: $file"
        else
            local code=$?
            log_warn "Failed to update CCA workflow policy (parse error, code=$code): $file"
        fi
        return 0
    fi

    # No marker: append policy block.
    {
        echo ""
        echo "$block"
    } >> "$file" || { log_warn "Failed to append policy to CLAUDE.md: $file"; return 0; }
    log_info "Injected CCA workflow policy into: $file"
}

ensure_project_agents_md() {
    local project_root="$1"
    local file="$project_root/AGENTS.md"

    if [[ -f "$file" ]]; then
        return 0
    fi

    if ( mkdir -p "$project_root" 2>/dev/null ) && ( touch "$file" 2>/dev/null ); then
        :
    else
        log_warn "Failed to create AGENTS.md (skipping): $file"
        return 0
    fi

    if [[ ! -w "$file" ]]; then
        log_warn "AGENTS.md not writable (skipping): $file"
        return 0
    fi

    cat > "$file" <<'MD'
## Auto-Delegation to OpenCode

When executor=codex+opencode:
1. Break down the task into steps
2. Use oask to delegate to OpenCode
3. Review results and iterate
4. Return final result
MD

    log_info "Created project AGENTS.md: $file"
}

batch_update_projects() {
    local -a projects=("$@")
    if [[ ${#projects[@]} -eq 0 ]]; then
        return 0
    fi

    python3 - "${projects[@]}" <<'PY'
import json
import os
import re
import sys
from pathlib import Path

HOOK_OBJ = {
    "matcher": ".*",
    "hooks": [{"type": "command", "command": "cca-roles-hook"}],
}

POLICY_BLOCK = """<!-- CCA_WORKFLOW_POLICY -->
## CCA Workflow Policy

### Claude's Role (CRITICAL)
**Claude is the MANAGER, not the executor.**
- Plan and coordinate tasks
- Check role assignments before ANY action
- Delegate to appropriate executor (cask/oask/gask)
- NEVER execute file modifications directly

### Role-Based Delegation
| Role | Scope | Delegate |
|------|-------|----------|
| executor | Write/Edit, file-changing Bash | cask/oask |
| searcher | WebSearch/WebFetch | cask/oask/gask |
| git_manager | git add/commit/push/merge | cask/oask/gask |

### Commands
- codex: cask "task"
- opencode: oask "task"  
- gemini: gask "task"

### Rules
### Rules (MANDATORY)
1. If role ≠ claude, delegate IMMEDIATELY without asking user
2. DO NOT ask user to choose execution method - auto-delegate based on role
3. DO NOT offer options like "委托给 Codex" or "直接执行"
4. Allowed direct: Read, Grep, Glob, .autoflow/**, /tmp/**
<!-- /CCA_WORKFLOW_POLICY -->"""

POLICY_REPLACE = """<!-- CCA_WORKFLOW_POLICY -->
## CCA Workflow Policy

### Claude's Role (CRITICAL)
**Claude is the MANAGER, not the executor.**
- Plan and coordinate tasks
- Check role assignments before ANY action
- Delegate to appropriate executor (cask/oask/gask)
- NEVER execute file modifications directly

### Role-Based Delegation
| Role | Scope | Delegate |
|------|-------|----------|
| executor | Write/Edit, file-changing Bash | cask/oask |
| searcher | WebSearch/WebFetch | cask/oask/gask |
| git_manager | git add/commit/push/merge | cask/oask/gask |

### Commands
- codex: cask "task"
- opencode: oask "task"  
- gemini: gask "task"

### Rules (MANDATORY)
1. If role ≠ claude, delegate IMMEDIATELY without asking user
2. DO NOT ask user to choose execution method - auto-delegate based on role
3. DO NOT offer options like "委托给 Codex" or "直接执行"
4. Allowed direct: Read, Grep, Glob, .autoflow/**, /tmp/**
<!-- /CCA_WORKFLOW_POLICY -->"""


def is_new_format_hook(entry: dict) -> bool:
    hs = entry.get("hooks")
    if not isinstance(hs, list):
        return False
    for h in hs:
        if not isinstance(h, dict):
            continue
        if h.get("type") == "command" and h.get("command") == "cca-roles-hook":
            return True
    return False


def matcher_to_str(matcher) -> str:
    if isinstance(matcher, str) and matcher:
        return matcher
    if isinstance(matcher, dict):
        tools = matcher.get("tools")
        if isinstance(tools, list):
            for t in tools:
                if isinstance(t, str) and t:
                    return t
        tool = matcher.get("tool")
        if isinstance(tool, str) and tool:
            return tool
    return ".*"


def migrate_old_entry(entry: dict) -> dict:
    new_matcher = matcher_to_str(entry.get("matcher"))
    cmds = entry.get("commands")
    new_hooks = []
    if isinstance(cmds, list):
        for c in cmds:
            if isinstance(c, str) and c:
                new_hooks.append({"type": "command", "command": c})
    else:
        new_hooks.append({"type": "command", "command": "cca-roles-hook"})
    return {"matcher": new_matcher, "hooks": new_hooks}


def update_settings(project_root: Path) -> None:
    claude_dir = project_root / ".claude"
    settings_path = claude_dir / "settings.json"
    claude_dir.mkdir(parents=True, exist_ok=True)

    data = {}
    if settings_path.exists():
        try:
            data = json.loads(settings_path.read_text(encoding="utf-8"))
            if not isinstance(data, dict):
                raise ValueError("settings.json is not an object")
        except Exception:
            sys.stderr.write(f"[cca] Invalid JSON (skipping): {settings_path}\n")
            return

    hooks = data.get("hooks")
    if not isinstance(hooks, dict):
        hooks = {}
        data["hooks"] = hooks

    pre = hooks.get("PreToolUse")
    if not isinstance(pre, list):
        pre = []
        hooks["PreToolUse"] = pre

    migrated = []
    changed = False
    for e in pre:
        if isinstance(e, dict) and "commands" in e:
            migrated.append(migrate_old_entry(e))
            changed = True
        else:
            migrated.append(e)
    pre[:] = migrated

    for e in pre:
        if isinstance(e, dict) and is_new_format_hook(e):
            m = e.get("matcher")
            m_str = matcher_to_str(m)
            if m != m_str:
                e["matcher"] = m_str
                changed = True

    if not any(is_new_format_hook(e) for e in pre if isinstance(e, dict)):
        pre.append(HOOK_OBJ)
        changed = True

    if changed or not settings_path.exists():
        try:
            settings_path.write_text(json.dumps(data, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")
        except Exception as e:
            sys.stderr.write(f"[cca] Failed to update .claude/settings.json: {settings_path} ({e})\n")


def update_claude_md(project_root: Path) -> None:
    file_path = project_root / "CLAUDE.md"
    start = "<!-- CCA_WORKFLOW_POLICY -->"

    if not file_path.exists():
        try:
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file_path.write_text(POLICY_BLOCK + "\n", encoding="utf-8")
        except Exception as e:
            sys.stderr.write(f"[cca] Failed to create CLAUDE.md (skipping policy): {file_path} ({e})\n")
        return

    if not os.access(file_path, os.W_OK):
        sys.stderr.write(f"[cca] CLAUDE.md not writable (skipping policy update): {file_path}\n")
        return

    try:
        text = file_path.read_text(encoding="utf-8", errors="replace")
    except Exception as e:
        sys.stderr.write(f"[cca] Failed to read CLAUDE.md: {file_path} ({e})\n")
        return

    if start in text:
        pattern = re.compile(r"<!-- CCA_WORKFLOW_POLICY -->.*?<!-- /CCA_WORKFLOW_POLICY -->", re.S)
        updated, n = pattern.subn(POLICY_REPLACE, text, count=1)
        if n == 0:
            sys.stderr.write(f"[cca] Failed to update CCA workflow policy (parse error): {file_path}\n")
            return
        if updated != text:
            if not updated.endswith("\n"):
                updated += "\n"
            try:
                file_path.write_text(updated, encoding="utf-8")
            except Exception as e:
                sys.stderr.write(f"[cca] Failed to write CLAUDE.md: {file_path} ({e})\n")
        return

    try:
        appended = text
        if appended and not appended.endswith("\n"):
            appended += "\n"
        appended += "\n" + POLICY_BLOCK + "\n"
        file_path.write_text(appended, encoding="utf-8")
    except Exception as e:
        sys.stderr.write(f"[cca] Failed to append policy to CLAUDE.md: {file_path} ({e})\n")


def main(paths: list[str]) -> int:
    for p in paths:
        if not p:
            continue
        root = Path(p)
        try:
            update_settings(root)
            update_claude_md(root)
            sys.stdout.write(f"OK:{p}\n")
        except Exception as e:
            sys.stderr.write(f"[cca] Batch update failed for {p}: {e}\n")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
PY
}

# Command: version
cmd_version() {
    local install_dir=""
    if install_dir="$(system_install_dir 2>/dev/null)"; then
        :
    else
        install_dir="$CCA_SOURCE"
    fi

    local commit date
    IFS='|' read -r commit date <<< "$(get_installed_version_info "$install_dir")"

    local extra=""
    [[ -n "${commit:-}" ]] && extra="$commit"
    [[ -n "${date:-}" ]] && extra="${extra:+$extra }$date"

    echo "cca v$VERSION${extra:+ $extra}"
    echo "Install/source: $install_dir"

    local remote_commit remote_date
    local remote
    if remote="$(get_remote_version_info 2>/dev/null)"; then
        IFS='|' read -r remote_commit remote_date <<< "$remote"
        if [[ -n "${commit:-}" && -n "${remote_commit:-}" ]]; then
            if [[ "$commit" == "$remote_commit" ]]; then
                echo "Status: up to date"
            else
                echo "Status: update available (${remote_commit}${remote_date:+ $remote_date})"
                echo "Run: cca update"
            fi
        else
            echo "Status: unable to compare versions"
        fi
    else
        echo "Status: unable to check updates (network/curl unavailable)"
    fi
}

# Install to a directory
do_install() {
    local target="$1"
    local type="${2:-project}"
    local install_date="${3:-}"

    [[ "$type" == "project" ]] || type="project"
    update_codex_config "$target" || true

    record_installation "$target" "$type" "${install_date:-}"
    log_info "Configured Codex permissions: $target"
}

# Remove from a directory
do_remove() {
    local target="$1"
    remove_codex_config "$target" || true
    remove_installation "$target"
    log_info "Removed Codex permissions config: $target"
}

# Command: add
cmd_add() {
    local target="$1"

    if [[ -z "$target" ]]; then
        log_error "Usage: cca add <.|path>"
        exit 1
    fi

    case "$target" in
	        ".")
	            target="$(pwd)"
	            log_blue "Configuring current project: $target"
	            do_install "$target" "project"
	            ensure_project_roles_config "$target" || true
	            ensure_project_skills "$target" "$CCA_SOURCE" || true
	            ensure_hook_installed || true
	            ensure_claude_settings_hook "$target" || true
	            ensure_project_claude_md_policy "$target" || true
	            ensure_project_agents_md "$target" || true
	            ;;
        *)
            # Resolve path
            if [[ "$target" != /* ]]; then
                target="$(pwd)/$target"
            fi
            target="$(cd "$target" 2>/dev/null && pwd)" || {
                log_error "Directory not found: $target"
                exit 1
	            }
	            log_blue "Configuring: $target"
	            do_install "$target" "project"
	            ensure_project_roles_config "$target" || true
	            ensure_project_skills "$target" "$CCA_SOURCE" || true
	            ensure_hook_installed || true
	            ensure_claude_settings_hook "$target" || true
	            ensure_project_claude_md_policy "$target" || true
	            ensure_project_agents_md "$target" || true
	            ;;
	    esac

	    echo ""
	    log_info "Done! AutoFlow is installed in this project (.claude/, .autoflow/)."
}

# Command: refresh
cmd_refresh() {
    local target="${1:-.}"

    case "$target" in
        ".") target="$(pwd)" ;;
        *)
            if [[ "$target" != /* ]]; then
                target="$(pwd)/$target"
            fi
            target="$(cd "$target" 2>/dev/null && pwd)" || {
                log_error "Directory not found: $target"
                exit 1
            }
            ;;
    esac

    python3 - "$target" <<'PY'
import json
import re
import sys
from pathlib import Path

project_root = Path(sys.argv[1])
roles_path = project_root / ".autoflow" / "roles.json"
claude_md = project_root / "CLAUDE.md"
agents_md = project_root / "AGENTS.md"

DEFAULT = {
    "schemaVersion": 1,
    "enabled": True,
    "executor": "codex",
    "searcher": "claude",
    "git_manager": "codex",
}

def read_roles() -> dict:
    if not roles_path.exists():
        return DEFAULT
    try:
        obj = json.loads(roles_path.read_text(encoding="utf-8"))
        if not isinstance(obj, dict):
            return DEFAULT
        if int(obj.get("schemaVersion", 0)) != 1:
            return DEFAULT
        if obj.get("enabled", True) is not True:
            return DEFAULT
        return {**DEFAULT, **obj}
    except Exception:
        return DEFAULT

def delegate_hint(role_value: str) -> str:
    v = (role_value or "").strip().lower()
    if v == "claude":
        return "direct"
    if v in {"codex", "codex+opencode"}:
        return 'cask "task"'
    if v == "opencode":
        return 'oask "task"'
    if v == "gemini":
        return 'gask "task"'
    return 'cask "task"'

def executor_rule(executor_value: str) -> str:
    v = (executor_value or "").strip()
    v_lower = v.lower()
    if delegate_hint(v) == "direct":
        return "can execute directly"
    if "+opencode" in v_lower:
        return f"{v} → MUST use cask (Codex will delegate to OpenCode via oask)"
    return "use " + delegate_hint(v)

roles = read_roles()
executor = str(roles.get("executor", DEFAULT["executor"]))
searcher = str(roles.get("searcher", DEFAULT["searcher"]))
git_manager = str(roles.get("git_manager", DEFAULT["git_manager"]))

lines: list[str] = []
lines.append("<!-- CCA_WORKFLOW_POLICY -->")
lines.append("## CCA Workflow Policy")
lines.append("")
lines.append("### Claude's Role (CRITICAL)")
lines.append("**Claude is the MANAGER, not the executor.**")
lines.append("- Plan and coordinate tasks")
lines.append("- Check role assignments before ANY action")
lines.append("- Delegate to appropriate executor (cask/oask/gask)")
lines.append("- NEVER execute file modifications directly")
lines.append("")
lines.append("### Current Roles")
lines.append(f"- executor: {executor} ({'direct' if delegate_hint(executor)=='direct' else 'delegate'})")
lines.append(f"- searcher: {searcher} ({'direct' if delegate_hint(searcher)=='direct' else 'delegate'})")
lines.append(f"- git_manager: {git_manager} ({'direct' if delegate_hint(git_manager)=='direct' else 'delegate'})")
lines.append("")
lines.append("### Delegation Rules")
lines.append(f"- executor: {executor_rule(executor)}")
lines.append(f"- searcher: {('can search directly' if delegate_hint(searcher)=='direct' else 'use ' + delegate_hint(searcher))}")
lines.append(f"- git_manager: {('can run git changes directly' if delegate_hint(git_manager)=='direct' else 'use ' + delegate_hint(git_manager))}")
lines.append("")
lines.append("### Allowed Direct Operations (when role=claude)")
lines.append("- Read/Grep/Glob")
lines.append("- Write to ~/.claude/plans/**, /tmp/**, .autoflow/**")
lines.append("<!-- /CCA_WORKFLOW_POLICY -->")
policy_block = "\n".join(lines) + "\n"

def upsert_policy(path: Path, block: str) -> None:
    if not path.exists():
        path.write_text(block, encoding="utf-8")
        return
    text = path.read_text(encoding="utf-8", errors="replace")
    pattern = re.compile(r"<!-- CCA_WORKFLOW_POLICY -->.*?<!-- /CCA_WORKFLOW_POLICY -->", re.S)
    if pattern.search(text):
        updated = pattern.sub(block.strip("\n"), text, count=1)
        if not updated.endswith("\n"):
            updated += "\n"
        path.write_text(updated, encoding="utf-8")
    else:
        if not text.endswith("\n"):
            text += "\n"
        path.write_text(text + "\n" + block, encoding="utf-8")

upsert_policy(claude_md, policy_block)

need_agents = "opencode" in (executor or "").lower()
if need_agents:
    agents_md.write_text(
        "## Auto-Delegation to OpenCode\n\n"
        "When executor=codex+opencode:\n"
        "1. Break down the task into steps\n"
        "2. Use oask to delegate to OpenCode\n"
        "3. Review results and iterate\n"
        "4. Return final result\n",
        encoding="utf-8",
    )
PY

    log_info "Refreshed: $target/CLAUDE.md"
    local roles_file="$target/.autoflow/roles.json"
    if [[ -f "$roles_file" ]]; then
        local executor
        executor="$(python3 - "$roles_file" <<'PY'
import json,sys
from pathlib import Path
p=Path(sys.argv[1])
try:
    obj=json.loads(p.read_text(encoding="utf-8"))
    if isinstance(obj, dict):
        print(obj.get("executor","").lower())
except Exception:
    pass
PY
)"
	    if [[ "$executor" == *"opencode"* ]]; then
	        log_info "Refreshed: $target/AGENTS.md"
	    fi
	fi
}

# Command: delete
cmd_delete() {
    local target="$1"

    if [[ -z "$target" ]]; then
        log_error "Usage: cca delete <.|path>"
        exit 1
    fi

    local reply=""
    _cca_confirm() {
        local prompt="$1"
        reply=""
        printf "%s" "$prompt" >&2
        if [[ -r /dev/tty ]]; then
            read -r reply < /dev/tty || true
        else
            read -r reply || true
        fi
        case "$(echo "${reply:-}" | tr '[:upper:]' '[:lower:]')" in
            y|yes) return 0 ;;
            *) return 1 ;;
        esac
    }

    case "$target" in
        ".")
            target="$(pwd)"
            log_blue "Preparing to remove AutoFlow from current project: $target"
            ;;
        *)
            if [[ "$target" != /* ]]; then
                target="$(pwd)/$target"
            fi
            target="$(cd "$target" 2>/dev/null && pwd)" || {
                log_error "Directory not found: $target"
                exit 1
            }
            log_blue "Preparing to remove AutoFlow from: $target"
            ;;
    esac

    echo ""
    echo "This will remove (cca-managed only):"
    echo "  - $target/.claude/skills/<autoflow skills>"
    echo "  - $target/.claude/commands/<cca-owned commands>"
    echo "  - PreToolUse cca-roles-hook entry from $target/.claude/settings.json"
    echo "  - CCA_WORKFLOW_POLICY block from $target/CLAUDE.md"
    echo "  - Installation record from: $INSTALLATIONS_FILE"
    echo "  - Codex project config from: $HOME/.codex/config.toml"

    echo ""
    if ! _cca_confirm "Proceed? [y/N] "; then
        log_warn "Cancelled."
        return 0
    fi

    remove_project_skills "$target" || true
    remove_project_hook "$target" || true
    remove_claude_md_policy "$target" || true

    if [[ -d "$target/.autoflow" ]]; then
        echo ""
        if _cca_confirm "Delete $target/.autoflow/ ? [y/N] "; then
            rm -rf "$target/.autoflow" 2>/dev/null || true
            log_info "Removed: $target/.autoflow/"
        else
            log_info "Kept: $target/.autoflow/"
        fi
    fi

    remove_codex_config "$target" || true
    remove_installation "$target"
    log_info "Removed AutoFlow config: $target"
}

# Command: update
cmd_update() {
    local mode=""
    local post_update=0
    local no_reexec=0
    local arg=""
    for arg in "$@"; do
        case "$arg" in
            --local) mode="--local" ;;
            --post-update) post_update=1 ;;
            --no-reexec) no_reexec=1 ;;
            "")
                ;;
            *)
                log_error "Unknown option for update: $arg"
                log_error "Usage: cca update [--local] [--no-reexec]"
                exit 1
                ;;
        esac
    done

    if [[ "$post_update" -eq 1 ]]; then
        local install_dir=""
        if install_dir="$(system_install_dir 2>/dev/null)"; then
            :
        else
            install_dir="$CCA_SOURCE"
        fi

        local installed_version
        installed_version="$(get_installed_version_string "$install_dir")"

        case "${CCA_POST_UPDATE_STATUS:-}" in
            updated)
                log_info "Updated to cca v$VERSION ($installed_version)"
                ;;
            uptodate)
                log_info "cca already up to date (v$VERSION $installed_version)"
                ;;
            *)
                log_info "cca version: v$VERSION ($installed_version)"
                ;;
        esac
        return 0
    fi

    require_platform
    local source_root=""

    if [[ "$mode" == "--local" ]]; then
        source_root="$CCA_SOURCE"
        log_blue "Refreshing configured projects from local source: $source_root"
    else
        local install_dir
        if ! install_dir="$(system_install_dir)"; then
            log_error "System installation not found: $CCA_INSTALL_PREFIX"
            log_error "Run: ./install.sh install"
            exit 1
        fi

        local before_commit before_date before_version
        IFS='|' read -r before_commit before_date <<< "$(get_installed_version_info "$install_dir")"
        before_version="$(get_installed_version_string "$install_dir")"
        local before_head=""
        if command -v git >/dev/null 2>&1 && [[ -d "$install_dir/.git" ]]; then
            before_head="$(git -C "$install_dir" rev-parse HEAD 2>/dev/null || true)"
        fi

        log_blue "Updating system installation: $install_dir"

        if command -v git >/dev/null 2>&1 && [[ -d "$install_dir/.git" ]]; then
            log_blue "Updating via git pull..."
            git -C "$install_dir" pull --ff-only
            log_blue "Syncing binaries after git update..."
            sync_bin_tools "$install_dir" || true
        else
            log_blue "Updating via tarball..."
            (
                set -euo pipefail
                command -v tar >/dev/null 2>&1 || { log_error "tar not found"; exit 1; }

                tmp_dir="$(mktemp -d 2>/dev/null || mktemp -d -t cca_update.XXXXXX)"
                trap 'rm -rf "$tmp_dir"' EXIT

                tarball_url="$CCA_REPO_URL/archive/refs/heads/main.tar.gz"
                tarball_path="$tmp_dir/main.tar.gz"

                if command -v curl >/dev/null 2>&1; then
                    curl -fsSL -o "$tarball_path" "$tarball_url"
                elif command -v wget >/dev/null 2>&1; then
                    wget -q -O "$tarball_path" "$tarball_url"
                else
                    log_error "Missing dependency: curl or wget"
                    exit 1
                fi

                tar -xzf "$tarball_path" -C "$tmp_dir"

                extracted_dir="$tmp_dir/claude_code_autoflow-main"
                if [[ ! -d "$extracted_dir" ]]; then
                    extracted_dir="$(find "$tmp_dir" -maxdepth 1 -type d -name '*-main' -print -quit 2>/dev/null || true)"
                fi
                [[ -d "$extracted_dir" ]] || { log_error "Failed to extract tarball"; exit 1; }

                remote_commit=""
                remote_date=""
                remote="$(get_remote_version_info 2>/dev/null || true)"
                if [[ -n "${remote:-}" ]]; then
                    IFS='|' read -r remote_commit remote_date <<< "$remote"
                fi

                detected_bin_dir="$CCA_BIN_DIR"
                detected_bin_dir="$(dirname "$(command -v cca 2>/dev/null || echo "$CCA_BIN_DIR/cca")")"

                CCA_INSTALL_PREFIX="$install_dir" \
                    CCA_BIN_DIR="$detected_bin_dir" \
                    CCA_GIT_COMMIT="${remote_commit:-}" \
                    CCA_GIT_DATE="${remote_date:-}" \
                    bash "$extracted_dir/install.sh" install
            )
        fi

        local after_commit after_date after_version
        IFS='|' read -r after_commit after_date <<< "$(get_installed_version_info "$install_dir")"
        after_version="$(get_installed_version_string "$install_dir")"
        local after_head=""
        if command -v git >/dev/null 2>&1 && [[ -d "$install_dir/.git" ]]; then
            after_head="$(git -C "$install_dir" rev-parse HEAD 2>/dev/null || true)"
        fi

        local version_changed=1
        if [[ -n "${before_commit:-}" && -n "${after_commit:-}" && "$before_commit" == "$after_commit" ]]; then
            log_info "cca already up to date ($after_version)"
            version_changed=0
        else
            log_info "cca updated: ${before_version} -> ${after_version}"
            if [[ -n "${before_head:-}" && -n "${after_head:-}" && "$before_head" != "$after_head" ]]; then
                log_blue "Recent changes:"
                git -C "$install_dir" log --oneline -5 "${before_head}..${after_head}" 2>/dev/null | sed 's/^/  /' || true
            fi
        fi

        CCA_SOURCE="$install_dir"
        source_root="$install_dir"
        if [[ "$version_changed" -eq 1 ]]; then
            log_info "Updated system installation"
        else
            log_info "System installation already up to date"
        fi

        # Export a lightweight status marker for the post-update re-exec.
        if [[ "$version_changed" -eq 1 ]]; then
            export CCA_POST_UPDATE_STATUS="updated"
        else
            export CCA_POST_UPDATE_STATUS="uptodate"
        fi
    fi

    if detect_legacy_global; then
        echo ""
        log_warn "Found legacy global config."
        local ans="y"
        if [[ -t 0 ]]; then
            read -r -p "Found legacy global config. Migrate to project-local? [Y/n] " ans || ans="y"
            echo ""
        else
            ans="y"
        fi
        ans="$(echo "${ans:-}" | tr '[:upper:]' '[:lower:]')"
        if [[ -z "$ans" || "$ans" == "y" || "$ans" == "yes" ]]; then
            cleanup_legacy_global || true
        fi
    fi

    local -a _install_lines=()
    while IFS= read -r line || [[ -n "$line" ]]; do
        _install_lines+=("$line")
    done < "$INSTALLATIONS_FILE" 2>/dev/null || true

    local count=0
    local -a _valid_projects=()
    for line in "${_install_lines[@]+"${_install_lines[@]}"}"; do
        [[ -z "${line//[[:space:]]/}" ]] && continue
        IFS='|' read -r path type date <<< "$line"
        [[ -z "${path:-}" ]] && continue
        if [[ -d "$path" ]]; then
            log_blue "Refreshing project config: $path"
            do_install "$path" "${type:-project}" "${date:-}"
            ensure_project_skills "$path" "$source_root" || true
            _valid_projects+=("$path")
            ((count+=1))
        else
            log_warn "Skipping (not found): $path"
            remove_installation "$path"
        fi
    done

    if [[ ${#_valid_projects[@]} -gt 0 ]]; then
        log_blue "Batch updating .claude/settings.json + CLAUDE.md for ${#_valid_projects[@]} project(s)..."
        batch_update_projects "${_valid_projects[@]}" || true
    fi

    echo ""
    log_info "Updated $count project(s)"

    # Hot-reexec into the updated cca binary so the user sees final status from the new version.
    if [[ "$mode" != "--local" && "$no_reexec" -ne 1 ]]; then
        local bin_cca=""
        bin_cca="$(command -v cca 2>/dev/null || true)"
        if [[ -z "${bin_cca:-}" ]]; then
            if install_dir="$(system_install_dir 2>/dev/null)"; then
                bin_cca="$install_dir/cca"
            fi
        fi

        if [[ -n "${bin_cca:-}" && -x "$bin_cca" ]]; then
            exec "$bin_cca" update --post-update
        else
            log_warn "Unable to re-exec updated cca (not found/executable); run 'cca version' to confirm."
        fi
    fi
}

# Command: list
cmd_list() {
    log_blue "Configured projects:"
    echo ""

    # Check if file has any non-whitespace content
    if ! grep -q '[^[:space:]]' "$INSTALLATIONS_FILE" 2>/dev/null; then
        echo "  (none)"
        return
    fi

    printf "  %-50s %-10s %s\n" "PATH" "TYPE" "DATE"
    printf "  %-50s %-10s %s\n" "----" "----" "----"

    while IFS='|' read -r path type date; do
        [[ -z "$path" ]] && continue
        local status=""
        if codex_project_configured "$path"; then
            status="${GREEN}✓${NC}"
        else
            status="${RED}✗${NC}"
        fi
        printf "  %-50s %-10s %s %b\n" "$path" "$type" "$date" "$status"
    done < "$INSTALLATIONS_FILE"
}

# Command: uninstall
cmd_uninstall() {
    log_warn "This will remove cca from your system."
    echo ""
    read -p "Remove all configured project entries from Codex config too? [y/N] " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Remove all configured projects (best effort).
        local -a _install_lines=()
        while IFS= read -r line || [[ -n "$line" ]]; do
            _install_lines+=("$line")
        done < "$INSTALLATIONS_FILE" 2>/dev/null || true
        for line in "${_install_lines[@]+"${_install_lines[@]}"}"; do
            [[ -z "${line//[[:space:]]/}" ]] && continue
            IFS='|' read -r path type date <<< "$line"
            [[ -z "${path:-}" ]] && continue
            do_remove "$path" || true
        done
    fi

    # Remove cca binary
    local cca_path="$(which cca 2>/dev/null)"
    if [[ -n "$cca_path" ]] && [[ -f "$cca_path" ]]; then
        rm -f "$cca_path"
        log_info "Removed: $cca_path"
    fi

    # Remove system install copy
    local install_dir=""
    if install_dir="$(system_install_dir 2>/dev/null)"; then
        rm -rf "$install_dir" 2>/dev/null || true
        log_info "Removed: $install_dir"
    fi

    # Remove cca config
    rm -rf "$CCA_HOME"
    log_info "Removed: $CCA_HOME"

    echo ""
    log_info "cca uninstalled. Goodbye!"
}

# Main
case "${1:-}" in
    add)
        cmd_add "$2"
        ;;
    refresh)
        cmd_refresh "${2:-.}"
        ;;
    delete|remove|rm)
        cmd_delete "$2"
        ;;
    update|upgrade)
        cmd_update "${@:2}"
        ;;
    list|ls)
        cmd_list
        ;;
    uninstall)
        cmd_uninstall
        ;;
    version|-v|--version)
        cmd_version
        ;;
    help|-h|--help|"")
        usage
        ;;
    *)
        log_error "Unknown command: $1"
        echo "Run 'cca help' for usage."
        exit 1
        ;;
esac
